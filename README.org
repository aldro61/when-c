** When to write low-level (C/C++) instead of high-level (R/Python) code?

In general the answer is: use a low-level language when there is no
efficient high-level implementation. Some examples:f
- You need complex data structures, for example that keep a bunch of stuff sorted in a certain way.
  In that case you should definitely use C++ and the [[http://en.wikipedia.org/wiki/Standard_Template_Library][STL]].
  For example the STL 
  [[http://www.cplusplus.com/reference/map/multimap/][multimap]] is a
  [[http://en.wikipedia.org/wiki/Red%E2%80%93black_tree][red-black tree]] which I used in
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/clusterpath/src/?root=clusterpath][clusterpath]].
  Another example is 
  [[https://github.com/tdhock/DiffPeaks][DiffPeaks]]
  which also uses the
  [[http://www.cplusplus.com/reference/set/set/][set]],
  [[http://www.cplusplus.com/reference/list/][list]], and
  [[http://www.cplusplus.com/reference/map/map/][map]] containers.
- You need to perform scalar operations that can't be expressed
  without performing some redundant computations 
  using vector or matrix operations.
  In that case you should use arrays in C.
  For example I scan things along the genome in
  [[https://github.com/tdhock/PeakError][PeakError]],
  [[https://github.com/tdhock/SparseSignals][SparseSignals]], and
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/?root=berr][breakpointError]].
- There is some high quality library code in a low-level language that 
  is already written and you just want to use it in your high-level language.
  For example regular expression support in R is lacking,
  so I wrote
  [[https://github.com/tdhock/revector][the revector package]]
  so I can parse a character vector using a matching vector of
  [[http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions][Perl-compatible regular expressions]].

** When to NOT write low-level code?

- You can express your computation in terms of matrix-vector or vector-scalar operations
  (or other R/Python functions which are already implemented in low-level C code).
  In that case you should just write R code or python numpy code.
  For example the R code in my 
  [[https://github.com/tdhock/WeightedROC/blob/master/R/ROC.R][WeightedROC]]
  package uses the vectorized cumsum function to compute a weighted
  [[http://en.wikipedia.org/wiki/Receiver_operating_characteristic][Receiver Operating Characteristic (ROC) curve]]
  faster than the 
  [[http://cran.r-project.org/web/packages/pROC/index.html][pROC package]]
  (which actually uses C code in some cases,
  but has a lot of overhead in R code that slows it down).
- You are waiting for your high-level R/Python code to compute.
  In that case you should use a code profiler,
  which will tell you which functions in your code are taking the most time.
  Try using
  [[https://stat.ethz.ch/R-manual/R-devel/library/utils/html/Rprof.html][the Rprof function]]
  and reading 
  [[http://adv-r.had.co.nz/Profiling.html][Hadley Wickham's guide to Profiling R code]].
  For Python take a look at [[https://docs.python.org/2/library/profile.html][profile/cProfile]].
  Usually, there is one function that takes 90% of the time,
  and you can just re-write that function in terms of vector operations in high-level R/Python code.
  If your code is still slow after that,
  then you should start thinking about re-writing that one slow function in low-level code.
- Your program uses all available memory and starts swapping.
  In that case maybe you can break your problem into separate tasks that can be computed independently?
  It may be useful to know how much memory R is using, via
  =cat(’point 1 mem’, memory.size(), memory.size(max=TRUE), ’\n’)=
  (from Circle 2 Growing Objects of [[http://www.burns-stat.com/pages/Tutor/R_inferno.pdf][The R Inferno by Patrick Burns]]).
  If so, then just read the first data subset into memory,
  perform the first computation,
  write the first result to disk,
  erase the first data subset from memory,
  read the second data subset into memory,
  etc. This is also the basic idea behind
  [[http://cbio.ensmp.fr/~thocking/r-cbio-cluster.html][parallelization using qsub to launch jobs on a computer cluster]].
  
** How to interface C code with Python or R?

If you are careful you can write C code that interfaces with both Python and R with little or no changes.
For example take a look at my SegAnnot project which has both R and Python bindings
(if you want to interface even more languages you should use
[[http://www.swig.org/][Simplified Wrapper and Interface Generator]]).

*** SegAnnot R package

Full documentation is in the [[http://cran.r-project.org/doc/manuals/r-release/R-exts.html#Interface-functions-_002eC-and-_002eFortran][Foreign Function Interface part of the Writing R Extensions Manual]],
but it may be easier to start with 
[[http://adv-r.had.co.nz/Rcpp.html][Hadley Wickham's guide to Rcpp]].

- [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/FindOptimalSegmentations.c?view=markup&revision=15&root=segannot][SegAnnot/src/FindOptimalSegmentations.c]]
  contains the C code which defines the bases function.
  It takes several arguments which can be anything,
  and it returns an integer error code.
  Make sure to #include "FindOptimalSegmentations.h" at the top,
  and define the error codes in that file.
- [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/FindOptimalSegmentations.h?view=markup&revision=15&root=segannot][SegAnnot/src/FindOptimalSegmentations.h]]
  is a C header file which defines the prototype (inputs and outputs) of the bases function which computes the optimal segmentation.
- In [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/bridge.c?view=markup&revision=15&root=segannot][SegAnnot/src/bridge.c]] we define the bridge_bases function which can be used in R.
  All .C bridge functions must take pointers as arguments, and return void.
  Make sure to put #include "FindOptimalSegmentations.h" at the top of this file.
  Note that the bridge function should check the integer error code returned by bases()
  and then call error("some error message") if necessary.
- The only other thing you need to get a working R package is to put
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/NAMESPACE?view=markup&revision=2&root=segannot][useDynLib("SegAnnot")]]
  in the SegAnnot/NAMESPACE file.
- On the command line do R CMD INSTALL SegAnnot
  and in the R code do library(SegAnnot),
  then you can call [[https://r-forge.r-project.org/scm/viewvc.php/pkg/R/findOptimalSegmentations.R?view=markup&revision=25&root=segannot][.C("bridge_bases")]]

*** Python extension module SegAnnot.so

The files in the Python package are analogous to those in the R package.
Full docs are in [[https://docs.python.org/2/extending/extending.html][the Python documentation for extension modules]]
and the [[http://docs.scipy.org/doc/numpy/user/c-info.how-to-extend.html#writing-an-extension-module][numpy extension module documentation]].

- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot.c?view=markup&revision=29&root=segannot][SegAnnot.c]]
  contains the C code which defines the SegAnnotBases function.
  Its arguments can be anything,
  and it returns an integer error code.
  Again note that we #include "SegAnnot.h"
  which defines the error codes.
  Note that this code is pretty much exactly the same as FindOptimalSegmentations.c in the R package.
- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot.h?view=markup&revision=29&root=segannot][SegAnnot.h]]
  contains the prototype of the SegAnnotBases function.
- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot_interface.c?view=markup&revision=29&root=segannot][SegAnnot_interface.c]]
  defines the bridge function SegAnnotBases2Py which converts the C data structures to Python data structures.
  Typically with numerical algorithms you will need to #include <numpy/arrayobject.h>
  and then start by converting Python data to C data,
  by calling PyArg_ParseTuple with a "O!" for each numpy vector you want to convert.
  You should read both the standard Python docs and the numpy docs about this function.
  Then we call SegAnnotBases, check for an error code, call PyErr_SetString if necessary,
  and then call Py_BuildValue with a bunch of "s:N" strings to make numpy vectors
  (also rtfm about these functions).
  Finally look at the bottom of that file for Methods which defines the docstring,
  and initSegAnnot which must contain import_array() to prevent numpy from crashing python.
- To get a working python module you need to make
  [[https://r-forge.r-project.org/scm/viewvc.php/python/setup.py?view=markup&revision=31&root=segannot][a setup.py file with ext_modules]].
  Then you can python setup.py install your code,
  which will make a SegAnnot.so file.
  If it is on your PYTHONPATH then you can use it via =from SegAnnot import SegAnnotBases=
  as I do in [[https://gforge.inria.fr/scm/viewvc.php/webapp/pyramid/plotter/db.py?view=markup&revision=1435&root=breakpoints][the SegAnnDB source code]].

** What is the difference between .C and .Call in R?

R has two ways to call compiled code: .C and .Call.
- If you already have some C code with int/double (pointer) arguments and return values,
  then .C can be used to call that code with R integer/numeric vectors.
- If you want to input/output more complicated R data structures like lists in your compiled code,
  then you should use .Call.
  
The .Call interface is a bit more difficult to use since you have to learn the internal C functions defined by R.
In contrast .C is limited to input/output of C arrays (R vectors),
but it is still quite useful for numerical algorithms.
My rule of thumb is that I use .C if I know the size of the outputs in advance,
and otherwise I use .Call.
One example for which the size of the output is not known in advance is
[[https://github.com/tdhock/SparseSignals/blob/master/src/interface.c][SparseSignals]],
in which I used .Call.

My [[https://r-forge.r-project.org/scm/viewvc.php/pkg/?root=berr][breakpointError]] package
is a simple example package that shows how to use both of these interfaces.

*** [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/breakpointError.c?view=markup&revision=2&root=berr][src/breakpointError.c]] defines two C functions

- int errorDetails(...) takes several int, int*, double* then returns an integer error code.
- double breakpointError(...) takes several int, int* 
  then returns a double which is negative for an error,
  otherwise it is the breakpointError.
  
*** [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/breakpointError.h?view=markup&revision=2&root=berr][src/breakpointError.h]] defines prototypes and error codes

You need to write #include "breakpointError.h" at the top of interface.c and breakpointError.c.

*** [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/interface.c?view=markup&revision=2&root=berr][src/interface.c]] contains the interface/bridge functions

- Inputs/outputs of errorDetails_interface are SEXP (all R data is SEXP) and this can be used with .Call.
  It calls errorDetails and checks the return value for an error code,
  calling error() if necessary.
  Note to access SEXP and R internal C functions such as allocVector you need to #include <R.h> and
  #include <Rinternals.h> at the top of the C code file.
- breakpointError_interface inputs are pointers and output is void.
  This function can be used with .C -- note how much simpler C code this is!

*** [[https://r-forge.r-project.org/scm/viewvc.php/pkg/R/breakpointError.R?view=markup&revision=2&root=berr][R/breakpointError.R]] contains the R code with .C/.Call 

- The C function errorDetails_interface can be accessed from R using .Call("errorDetails_interface")
  which returns the R list that was constructed in the C code.
  Note how simple this is, since all the work was done in the C code.
- The C function breakpointError_interface can be accessed from R using .C("breakpointError_interface")
  which returns an R list. The interesting component of the list is named "error" 
  and it is a numeric scalar. We need to check if it is negative and if so stop() with an error.

*** Exercise for the reader

Since the sizes of the outputs of errorDetails are known in advance,
it is possible to implement it using .C -- do it!
