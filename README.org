** When to write low-level (C/C++) instead of high-level (R/Python) code?

In general the answer is: use a low-level language when there is no
efficient high-level implementation. Some examples:
- You need complex data structures, for example that keep a bunch of stuff sorted in a certain way.
  In that case you should definitely use C++ and the [[http://en.wikipedia.org/wiki/Standard_Template_Library][STL]].
  For example the STL 
  [[http://www.cplusplus.com/reference/map/multimap/][multimap]] is a
  [[http://en.wikipedia.org/wiki/Red%E2%80%93black_tree][red-black tree]] which I used in
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/clusterpath/src/?root=clusterpath][clusterpath]].
  Another example is 
  [[https://github.com/tdhock/DiffPeaks][DiffPeaks]]
  which also uses the
  [[http://www.cplusplus.com/reference/set/set/][set]],
  [[http://www.cplusplus.com/reference/list/][list]], and
  [[http://www.cplusplus.com/reference/map/map/][map]] containers.
- You need to perform scalar operations that can't be expressed
  without performing some redundant computations 
  using vector or matrix operations.
  In that case you should use arrays in C.
  For example I scan things along the genome in
  [[https://github.com/tdhock/PeakError][PeakError]],
  [[https://github.com/tdhock/SparseSignals][SparseSignals]], and
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/?root=berr][breakpointError]].
- There is some high quality library code in a low-level language that 
  is already written and you just want to use it in your high-level language.
  For example regular expression support in R is lacking,
  so I wrote
  [[https://github.com/tdhock/revector][the revector package]]
  so I can parse a character vector using a matching vector of
  [[http://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions][Perl-compatible regular expressions]].
  
** When to NOT write low-level code?

- You can express your computation in terms of matrix-vector or vector-scalar operations
  (or other R functions which are already implemented in low-level C code).
  In that case you should just write R code or python numpy code.
  For example the R code in my 
  [[https://github.com/tdhock/WeightedROC/blob/master/R/ROC.R][WeightedROC]]
  package uses the vectorized cumsum function to compute a weighted
  [[http://en.wikipedia.org/wiki/Receiver_operating_characteristic][Receiver Operating Characteristic (ROC) curve]]
  faster than the 
  [[http://cran.r-project.org/web/packages/pROC/index.html][pROC package]]
  (which actually uses C code in some cases,
  but has a lot of overhead in R code that slows it down).
  
** How to interface C code with Python or R?

If you are careful you can write C code that interfaces with both Python and R with little or no changes.
For example take a look at my SegAnnot project.

*** SegAnnot R package

Full documentation is in the [[http://cran.r-project.org/doc/manuals/r-release/R-exts.html#Interface-functions-_002eC-and-_002eFortran][Foreign Function Interface part of the Writing R Extensions Manual]].

- [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/FindOptimalSegmentations.c?view=markup&revision=15&root=segannot][SegAnnot/src/FindOptimalSegmentations.c]]
  contains the C code which defines the bases function.
  It takes several arguments which can be anything,
  and it returns an integer error code.
  Make sure to #include "FindOptimalSegmentations.h" at the top,
  and define the error codes in that file.
- [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/FindOptimalSegmentations.h?view=markup&revision=15&root=segannot][SegAnnot/src/FindOptimalSegmentations.h]]
  is a C header file which defines the prototype (inputs and outputs) of the bases function which computes the optimal segmentation.
- In [[https://r-forge.r-project.org/scm/viewvc.php/pkg/src/bridge.c?view=markup&revision=15&root=segannot][SegAnnot/src/bridge.c]] we define the bridge_bases function which can be used in R.
  All .C bridge functions must take pointers as arguments, and return void.
  Make sure to put #include "FindOptimalSegmentations.h" at the top of this file.
  Note that the bridge function should check the integer error code returned by bases()
  and then call error("some error message") if necessary.
- The only other thing you need to get a working R package is to put
  [[https://r-forge.r-project.org/scm/viewvc.php/pkg/NAMESPACE?view=markup&revision=2&root=segannot][useDynLib("SegAnnot")]]
  in the SegAnnot/NAMESPACE file.
- On the command line do R CMD INSTALL SegAnnot
  and in the R code do library(SegAnnot),
  then you can call [[https://r-forge.r-project.org/scm/viewvc.php/pkg/R/findOptimalSegmentations.R?view=markup&revision=25&root=segannot][.C("bridge_bases")]]

*** Python extension module SegAnnot.so

The files in the Python package are analogous to those in the R package.
- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot.c?view=markup&revision=29&root=segannot][SegAnnot.c]]
  contains the C code which defines the SegAnnotBases function.
  Its arguments can be anything,
  and it returns an integer error code.
  Again note that we #include "SegAnnot.h"
  which defines the error codes.
  Note that this code is pretty much exactly the same as FindOptimalSegmentations.c in the R package.
- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot.h?view=markup&revision=29&root=segannot][SegAnnot.h]]
  contains the prototype of the SegAnnotBases function.
- [[https://r-forge.r-project.org/scm/viewvc.php/python/SegAnnot_interface.c?view=markup&revision=29&root=segannot][SegAnnot_interface.c]]
  defines the bridge function SegAnnotBases2Py which converts the C data structures to Python data structures.
  Typically with numerical algorithms you will need to #include <numpy/arrayobject.h>
  and then start by converting Python data to C data,
  by calling PyArg_ParseTuple with a "O!" for each numpy vector you want to convert.
  You should read both the standard Python docs and the numpy docs about this function.
  Then we call SegAnnotBases, check for an error code, call PyErr_SetString if necessary,
  and then call Py_BuildValue with a bunch of "s:N" strings to make numpy vectors
  (also rtfm about these functions).
  Finally look at the bottom of that file for Methods which defines the docstring,
  and initSegAnnot which must contain import_array() to prevent numpy from crashing python.
- To get a working python module you need to make
  [[https://r-forge.r-project.org/scm/viewvc.php/python/setup.py?view=markup&revision=31&root=segannot][a setup.py file with ext_modules]].
  Then you can python setup.py install your code,
  which will make a SegAnnot.so file.
  If it is on your PYTHONPATH then you can use it via from SegAnnot import SegAnnot.

  
